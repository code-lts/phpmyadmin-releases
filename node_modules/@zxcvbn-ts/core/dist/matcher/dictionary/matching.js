'use strict';

var helper = require('../../helper.js');
var Options = require('../../Options.js');
var reverse = require('./variants/matching/reverse.js');
var l33t = require('./variants/matching/l33t.js');

class MatchDictionary {
  constructor() {
    this.l33t = new l33t(this.defaultMatch);
    this.reverse = new reverse(this.defaultMatch);
  }

  match({
    password
  }) {
    const matches = [...this.defaultMatch({
      password
    }), ...this.reverse.match({
      password
    }), ...this.l33t.match({
      password
    })];
    return helper.sorted(matches);
  }

  defaultMatch({
    password
  }) {
    // rankedDictionaries variable is for unit testing purposes
    const matches = [];
    const passwordLength = password.length;
    const passwordLower = password.toLowerCase();
    Object.keys(Options.rankedDictionaries).forEach(dictionaryName => {
      const rankedDict = Options.rankedDictionaries[dictionaryName];

      for (let i = 0; i < passwordLength; i += 1) {
        for (let j = i; j < passwordLength; j += 1) {
          if (passwordLower.slice(i, +j + 1 || 9e9) in rankedDict) {
            const word = passwordLower.slice(i, +j + 1 || 9e9);
            const rank = rankedDict[word];
            matches.push({
              pattern: 'dictionary',
              i,
              j,
              token: password.slice(i, +j + 1 || 9e9),
              matchedWord: word,
              rank,
              dictionaryName: dictionaryName,
              reversed: false,
              l33t: false
            });
          }
        }
      }
    });
    return matches;
  }

}

module.exports = MatchDictionary;
//# sourceMappingURL=matching.js.map
