import { buildRankedDictionary } from './helper.esm.js';
import l33tTable from './data/l33tTable.esm.js';
import translationKeys from './data/translationKeys.esm.js';

class Options {
  constructor() {
    this.matchers = {};
    this.l33tTable = l33tTable;
    this.dictionary = {
      userInput: []
    };
    this.rankedDictionaries = {};
    this.translations = translationKeys;
    this.graphs = {};
    this.availableGraphs = [];
    this.setRankedDictionaries();
  }

  setOptions(options = {}) {
    if (options.l33tTable) {
      this.l33tTable = options.l33tTable;
    }

    if (options.dictionary) {
      this.dictionary = options.dictionary;
      this.setRankedDictionaries();
    }

    if (options.translations) {
      this.setTranslations(options.translations);
    }

    if (options.graphs) {
      this.graphs = options.graphs;
    }
  }

  setTranslations(translations) {
    if (this.checkCustomTranslations(translations)) {
      this.translations = translations;
    } else {
      throw new Error('Invalid translations object fallback to keys');
    }
  }

  checkCustomTranslations(translations) {
    let valid = true;
    Object.keys(translationKeys).forEach(type => {
      if (type in translations) {
        const translationType = type;
        Object.keys(translationKeys[translationType]).forEach(key => {
          if (!(key in translations[translationType])) {
            valid = false;
          }
        });
      } else {
        valid = false;
      }
    });
    return valid;
  }

  setRankedDictionaries() {
    const rankedDictionaries = {};
    Object.keys(this.dictionary).forEach(name => {
      const list = this.dictionary[name];

      if (name === 'userInputs') {
        const sanitizedInputs = [];
        list.forEach(input => {
          const inputType = typeof input;

          if (inputType === 'string' || inputType === 'number' || inputType === 'boolean') {
            sanitizedInputs.push(input.toString().toLowerCase());
          }
        });
        rankedDictionaries[name] = buildRankedDictionary(sanitizedInputs);
      } else {
        rankedDictionaries[name] = buildRankedDictionary(list);
      }
    });
    this.rankedDictionaries = rankedDictionaries;
  }

  addMatcher(name, matcher) {
    if (this.matchers[name]) {
      throw new Error('Matcher already exists');
    }

    this.matchers[name] = matcher;
  }

}

var Options$1 = new Options();

export default Options$1;
//# sourceMappingURL=Options.esm.js.map
